# MemOS - AI 记忆操作系统：为 Agent 装上海马体

> 精读日期：2026-01-22
> 项目地址：https://github.com/MemTensor/MemOS
> 标签：#AI-Memory #Agent-Infrastructure #RAG-Alternative #LLM

## 📌 项目速览

| 项目 | 内容 |
|------|------|
| **项目名称** | MemOS (Memory Operating System) |
| **作者/组织** | MemTensor 团队 |
| **类型** | SDK / 框架 / 记忆系统基础设施 |
| **核心定位** | 行业首个 AI 记忆操作系统 |
| **技术栈** | Python 3.10+ / Neo4j / Qdrant / Redis / MySQL / FastAPI |
| **热度** | 3700+ Stars，v2.0 版本，有论文支撑 |

> **一句话价值**：MemOS 是为 AI Agent 设计的"海马体"——一个操作系统级别的记忆基础设施，让 AI 从"失忆症患者"进化为"有长期记忆的智能体"。

---

## 🎯 解决的核心痛点

### 传统 AI 的"失忆症"

```
用户第 1 次："我喜欢简洁的代码风格"
AI：好的，我会注意。

用户第 2 次（新对话）："帮我写个函数"
AI：好的！（完全忘记你喜欢简洁风格）

用户第 100 次："你还记得我的偏好吗？"
AI：抱歉，每次对话我都是从零开始...
```

### 当前方案的局限

| 方案 | 做法 | 问题 |
|------|------|------|
| **长 Context** | 塞更多历史进去 | Token 爆炸、成本高、速度慢 |
| **RAG** | 检索相关文档 | 无状态，不记"你是谁" |
| **System Prompt** | 手动写用户信息 | 无法自动更新、不可扩展 |
| **Knowledge Base** | 存文档知识 | 知识 ≠ 记忆（缺乏个性化） |

### MemOS 的思路

> 把记忆当成**系统资源**来管理，就像操作系统管理内存和硬盘一样。

---

## 🏗️ 三层记忆架构（核心创新）

```
┌─────────────────────────────────────────────────────────────┐
│                    MemOS 三层记忆架构                        │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  ┌─────────────────────────────────────────────────────┐   │
│  │           Layer 3: Memory Operating System           │   │
│  │  • 调度(Scheduling)：哪些记忆该激活、该遗忘？        │   │
│  │  • 生命周期管理：记忆的创建、更新、过期、归档        │   │
│  │  • 多租户隔离：不同用户/Agent 的记忆互不干扰        │   │
│  └─────────────────────────────────────────────────────┘   │
│                            ↓                                │
│  ┌─────────────────────────────────────────────────────┐   │
│  │           Layer 2: Memory Types (记忆类型)           │   │
│  │  ┌──────────┬──────────┬──────────┬──────────┐      │   │
│  │  │ Textual  │Activation│Parametric│  Tool    │      │   │
│  │  │ Memory   │ Memory   │ Memory   │ Memory   │      │   │
│  │  │ 文本记忆 │ 激活缓存 │ LoRA权重 │ 工具轨迹 │      │   │
│  │  └──────────┴──────────┴──────────┴──────────┘      │   │
│  └─────────────────────────────────────────────────────┘   │
│                            ↓                                │
│  ┌─────────────────────────────────────────────────────┐   │
│  │           Layer 1: Storage Backend (存储层)          │   │
│  │  ┌──────────┬──────────┬──────────┬──────────┐      │   │
│  │  │  Neo4j   │  Qdrant  │  Redis   │  MySQL   │      │   │
│  │  │ 关系图谱 │ 向量检索 │ 高速缓存 │ 结构化   │      │   │
│  │  └──────────┴──────────┴──────────┴──────────┘      │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 四种记忆类型

| 类型 | 存什么 | 用途 | 类比 |
|------|--------|------|------|
| **Textual Memory** | 对话内容、用户说的话 | 回忆"你说过什么" | 日记本 |
| **Activation Memory** | 推理中间状态、KV Cache | 加速推理、省 Token | 工作记忆/短期记忆 |
| **Parametric Memory** | LoRA 权重、微调参数 | 个性化模型行为 | 肌肉记忆/技能 |
| **Tool Memory** | Agent 调用工具的轨迹 | 避免重复犯错 | 经验教训 |

---

## 🆚 与 RAG / Claude Memory 的对比

| 维度 | 传统 RAG | Claude Memory | MemOS |
|------|---------|---------------|-------|
| **本质** | 检索增强 | 对话记忆 | 记忆操作系统 |
| **状态** | 无状态 | 有状态（有限） | 有状态（完整生命周期） |
| **记忆类型** | 只有文档 | 用户偏好+事实 | 多类型（文本/激活/参数/工具） |
| **更新机制** | 手动重索引 | 自动提取 | 动态调度 + 自动遗忘 |
| **多模态** | 需额外处理 | 有限 | 原生支持（图片/文档/图表） |
| **跨对话** | 不支持 | 支持 | 支持 + 跨 Agent |
| **可控性** | 低 | 中 | 高（完整 API） |

### 核心区别

```
RAG = "图书馆管理员"
     → 你问什么，我去书架找

Claude Memory = "秘书助理"
     → 我记得你说过的重要事情

MemOS = "大脑海马体"
     → 我管理你所有记忆的存储、检索、更新、遗忘
```

---

## ⚙️ 调度系统设计

```
┌─────────────────────────────────────────────────────────┐
│                  MemOS 调度系统                          │
├─────────────────────────────────────────────────────────┤
│                                                         │
│   请求进入                                               │
│      │                                                  │
│      ▼                                                  │
│   ┌─────────────────┐                                   │
│   │  Redis Streams  │  ← 多级队列，处理高并发            │
│   │   调度器        │                                   │
│   └────────┬────────┘                                   │
│            │                                            │
│      ┌─────┴─────┐                                      │
│      │  决策：    │                                      │
│      │  哪些记忆  │                                      │
│      │  该激活？  │                                      │
│      └─────┬─────┘                                      │
│            │                                            │
│   ┌────────┼────────┬────────────┐                      │
│   ▼        ▼        ▼            ▼                      │
│ 热记忆   温记忆   冷记忆      归档记忆                    │
│ (Redis)  (Qdrant) (MySQL)    (对象存储)                 │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### 关键机制

- **记忆重要度打分**：根据访问频率、相关性等计算
- **访问频率衰减**：模拟人类遗忘曲线
- **自动遗忘**：低重要度记忆自动归档/删除
- **记忆压缩与合并**：相似记忆合并，节省存储

### Tool Memory 的妙用

```
无 Tool Memory：
├── 第 1 次调用 API → 报错
├── 第 2 次调用 → 同样报错
└── Agent："我不知道为什么一直失败..."

有 Tool Memory：
├── 第 1 次调用 → 报错 → 记录轨迹
├── 第 2 次调用 → 检索历史 → 发现上次报错原因
├── 换一种调用方式 → 成功
└── Agent："我记得上次这样调用会失败，换种方法..."
```

---

## 🚀 快速使用

### 方式 1：云服务（最简单）

```python
import os
import json

# 配置
os.environ["MEMOS_API_KEY"] = "your_key"
os.environ["MEMOS_BASE_URL"] = "https://memos.memtensor.cn/api/openmem/v1"
os.environ["KNOWLEDGE_BASE_IDS"] = json.dumps(["your_kb_id"])

# 三个核心 API
# 1. 搜索记忆
memories = search_memory(user_id, query)

# 2. 添加消息（自动生成记忆）
add_message(user_id, role="user", content="我喜欢简洁风格")

# 3. 获取消息历史
history = get_messages(user_id)
```

### 方式 2：本地部署

```bash
# 克隆项目
git clone https://github.com/MemTensor/MemOS.git
cd MemOS

# 启动依赖服务
docker-compose up -d

# 安装
pip install -e .

# 使用
from memos import MemOS
memos = MemOS()
memos.store("user_123", "preference", "喜欢简洁代码风格")
result = memos.recall("user_123", "代码风格偏好")
```

---

## 🔑 核心洞见

| 维度 | 洞见 |
|------|------|
| **产品本质** | AI 的"海马体"——记忆管理基础设施 |
| **核心创新** | 把记忆当"系统资源"管理，而非简单存储 |
| **技术壁垒** | 三层架构 + 多类型记忆 + 调度系统 |
| **vs RAG** | RAG 是检索，MemOS 是记忆生命周期管理 |
| **vs Claude Memory** | Claude 是功能，MemOS 是基础设施 |
| **适用场景** | 需要长期记忆、个性化、跨对话的 AI Agent |

---

## 💡 可迁移的设计模式

### 1. "记忆即资源"模式

不只是存数据，而是管理数据的生命周期：
- 创建 → 更新 → 遗忘 → 归档
- 可应用于：用户行为系统、推荐系统、个性化引擎

### 2. "多类型记忆分层"模式

不同类型的数据用不同的存储和策略：
- 热/温/冷分层
- 针对性优化（Redis 热数据、Qdrant 向量、MySQL 结构化）

### 3. "Tool Memory"模式

记录工具调用轨迹，避免重复犯错：
- 这是 AI Agent 系统设计的重要模式
- 让 Agent 从错误中学习

### 4. "调度器"抽象

- 用 Redis Streams 实现高并发多级队列
- 记忆重要度打分 + 自动遗忘
- 模拟人类记忆的运作方式

---

## 📊 与 Claude Memory 的定位对比

| 角度 | Claude Memory | MemOS |
|------|---------------|-------|
| **定位** | 产品功能 | 基础设施/框架 |
| **控制** | 黑盒 | 开源、完全可控 |
| **扩展** | 受限于 Anthropic 更新 | 自己迭代 |
| **集成** | 只能用 Claude | 可接任意 LLM |
| **适用** | 个人用户 | 企业级 Agent 系统 |

**结论**：如果你在构建需要长期记忆的 AI Agent 系统，MemOS 是现在就能用的开源方案，不用等 Claude 的"未来功能"。

---

## 📚 延伸资源

- **GitHub**: https://github.com/MemTensor/MemOS
- **文档**: 项目 README 及 docs 目录
- **API 控制台**: https://memos-dashboard.openmem.net/

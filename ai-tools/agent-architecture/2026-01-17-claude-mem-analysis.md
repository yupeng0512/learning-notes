---
title: "Claude-Mem 持久化记忆系统精读"
date: 2026-01-17
category: ai-tools/agent-architecture
tags: [claude-code, memory, agent, hook, vector-search]
source: https://github.com/thedotmack/claude-mem
---

# Claude-Mem 项目精读笔记

> 精读日期：2026-01-17
> 项目地址：https://github.com/thedotmack/claude-mem

## 📖 快速概览

| 项目 | 内容 |
|------|------|
| **项目名** | Claude-Mem |
| **作者** | Alex Newman (@thedotmack) |
| **类型** | Claude Code 插件（持久化记忆系统） |
| **核心价值** | 为 Claude Code 提供跨会话的持久化记忆能力 |
| **版本** | 6.5.0 |
| **许可证** | AGPL-3.0（ragtime 模块单独使用 PolyForm 非商业许可） |
| **阅读价值** | ⭐⭐⭐⭐⭐ 解决 AI Agent 的核心痛点——上下文记忆，架构设计精巧 |

> **一句话总结**：Claude-Mem 通过 5 个生命周期 Hook 自动捕获工具使用记录，压缩成语义摘要，并在未来会话中注入相关上下文，让 Claude 真正拥有"长期记忆"。

---

## 🗺️ 知识地图

### 项目架构

```
┌─────────────────────────────────────────────────────────────────┐
│                    Claude-Mem 架构                               │
├─────────────────────────────────────────────────────────────────┤
│  🔄 5 个生命周期 Hooks                                           │
│  ┌──────────┬──────────────┬──────────┬────────┬──────────┐     │
│  │SessionStart│UserPromptSubmit│PostToolUse│ Stop │SessionEnd│   │
│  │ 注入上下文 │  初始化会话   │ 记录观察  │ 生成摘要│ 清理资源 │   │
│  └──────────┴──────────────┴──────────┴────────┴──────────┘     │
├─────────────────────────────────────────────────────────────────┤
│  🛠️ Worker Service (Express + Bun, 端口 37777)                   │
│  ├─ HTTP API：处理 Hook 请求                                     │
│  ├─ AI 处理：生成语义摘要                                        │
│  ├─ Web Viewer：http://localhost:37777                          │
│  └─ MCP Search Tools：4 个搜索工具                               │
├─────────────────────────────────────────────────────────────────┤
│  💾 数据存储                                                     │
│  ├─ SQLite：~/.claude-mem/claude-mem.db                         │
│  │   └─ Sessions / Observations / Summaries / Timeline         │
│  └─ Chroma：~/.claude-mem/chroma/（向量搜索）                    │
├─────────────────────────────────────────────────────────────────┤
│  🔍 搜索系统                                                     │
│  ├─ FTS5 全文搜索                                                │
│  └─ Chroma 语义向量搜索（混合检索）                              │
└─────────────────────────────────────────────────────────────────┘
```

### 数据流转

```
用户使用 Claude Code 编程
           │
           ▼
    ┌──────────────────┐
    │ SessionStart Hook │ → 从数据库获取历史上下文，注入到 Claude
    └──────────────────┘
           │
           ▼
    ┌──────────────────┐
    │UserPromptSubmit  │ → 初始化会话，记录用户输入
    └──────────────────┘
           │
           ▼
    ┌──────────────────┐
    │  PostToolUse     │ → 每次工具调用后，记录"观察"(Observation)
    │  (核心 Hook)     │    包括：工具名、输入、输出、推理过程
    └──────────────────┘
           │
           ▼
    ┌──────────────────┐
    │   Stop Hook      │ → 会话结束时，生成语义摘要
    │                  │    使用 AI 压缩观察记录
    └──────────────────┘
           │
           ▼
    ┌──────────────────┐
    │   SQLite + Chroma│ → 持久化存储，支持语义搜索
    └──────────────────┘
           │
           ▼
     下次会话时，相关上下文自动注入 ←───────────────────────────┘
```

---

## 🔑 核心概念详解

### 1. 生命周期 Hooks

这是整个系统的核心机制，利用 Claude Code 的 Hook 系统在关键时刻介入：

| Hook | 触发时机 | 职责 |
|------|---------|------|
| **SessionStart** | 会话开始 | 1. 检查/安装依赖<br>2. 启动 Worker 服务<br>3. 注入历史上下文 |
| **UserPromptSubmit** | 用户发送消息 | 初始化会话、处理斜杠命令 |
| **PostToolUse** | 工具调用完成 | 捕获工具使用记录（观察） |
| **Stop** | 会话结束 | 使用 AI 生成语义摘要 |
| **SessionEnd** | 会话销毁 | 清理资源 |

### 2. 观察 (Observation)

每次工具调用后记录的结构化数据：

```typescript
{
  id: "#38783",           // 唯一标识
  session_id: "xxx",      // 所属会话
  tool_name: "read_file", // 工具名
  tool_input: {...},      // 工具输入
  tool_output: {...},     // 工具输出
  timestamp: "...",       // 时间戳
  type: "🔵",             // 类型标记（功能/Bug/决策...）
  title: "Context Hook..." // AI 生成的摘要标题
}
```

### 3. MCP 搜索工具

提供 4 个 MCP 工具，遵循 **3 层工作流模式**（节省 Token）：

| 工具 | 作用 | Token 消耗 |
|------|------|-----------|
| **search** | 搜索记忆索引 | ~50-100/条 |
| **timeline** | 查看时间线上下文 | 中等 |
| **get_observations** | 获取完整详情 | ~500-1000/条 |
| **__IMPORTANT** | 工作流文档 | - |

**最佳实践**：先用 `search` 获取索引 → 过滤相关 ID → 再用 `get_observations` 获取详情

```typescript
// 示例工作流
// 1. 搜索索引
search(query="authentication bug", type="bugfix", limit=10)

// 2. 审查索引，识别相关 ID (#123, #456)

// 3. 获取完整详情
get_observations(ids=[123, 456])
```

### 4. 渐进式披露 (Progressive Disclosure)

Claude-Mem 的上下文注入策略——不是一次性注入所有历史，而是：

1. **初始注入**：会话开始时注入精简的时间线索引
2. **按需获取**：Claude 通过 MCP 工具按需查询详情
3. **Token 节省**：相比全量注入，节省约 10 倍 Token

### 5. RAGTIME 模块

实验性功能（非商业许可），用于批量处理文档：

```typescript
// 顺序处理文件，每个文件处理完等待队列清空
for (const file of filesToProcess) {
  for await (const message of query({
    prompt: `Read ${file}...`,
    options: { plugins: [{ type: "local", path: pathToPlugin }] }
  })) {
    // 处理响应
  }
  await waitForQueueToEmpty(); // 等待 Worker 处理完成
}
```

---

## 💡 核心洞见

### 1. "记忆 = 方向盘"

没有记忆的 AI Agent 就像失忆症患者——每次对话都从零开始。Claude-Mem 让 AI 能够：
- 记住之前的架构决策
- 避免重复犯同样的错误
- 持续积累项目知识

### 2. 压缩而非存储原始数据

关键设计决策：
- **PostToolUse** 捕获原始工具调用
- **Stop Hook** 使用 AI 生成语义摘要
- 存储摘要而非原始数据，大幅节省存储和检索成本

### 3. Hook 架构的巧妙设计

利用 Claude Code 的原生 Hook 机制：
- **零侵入**：不修改 Claude Code 核心逻辑
- **自动化**：无需用户手动干预
- **可扩展**：新增 Hook 不影响现有功能

### 4. 隐私控制

通过 `<private>` 标签控制敏感内容：
```
<private>敏感内容不会被存储</private>
```
在 Hook 层（边缘处理）就剥离隐私内容，数据到达 Worker/数据库前已清洗。

---

## 🧩 技术栈

| 组件 | 技术 | 说明 |
|------|------|------|
| **运行时** | Bun + Node.js | Bun 管理 Worker 进程 |
| **API 服务** | Express | 端口 37777 |
| **数据库** | SQLite + FTS5 | 本地持久化 + 全文搜索 |
| **向量搜索** | Chroma | 语义相似度检索 |
| **AI 处理** | Claude Agent SDK | 生成摘要 |
| **前端** | React | Web Viewer UI |
| **构建** | TypeScript → ESM | 编译到 plugin/scripts/ |

---

## 🎯 苏格拉底式问答

### Q1: 为什么需要在 Hook 层而不是存储层剥离隐私内容？

**思考**：如果在存储层剥离，数据已经经过网络传输和 Worker 处理，存在泄露风险...

**答案**：Hook 层是"边缘处理"，是数据进入系统的第一道关卡。在这里剥离可以：
1. 防止敏感数据在网络传输中暴露
2. 避免 Worker 进程处理敏感内容
3. 确保日志和中间状态都不包含隐私数据

### Q2: 为什么使用 pass@k 和 pass^k 两种指标？

**思考**：在之前的 Agent 评估文章中提到过这两个指标，它们在这里有什么应用？

**答案**：
- **pass@k**（至少成功一次）：适合"搜索"场景——只要找到一条相关记忆就有价值
- **pass^k**（全部成功）：适合"关键操作"——需要每次都能正确回忆关键上下文

### Q3: 渐进式披露 vs 全量注入，如何选择？

**思考**：全量注入更简单，为什么要设计复杂的渐进式披露？

**答案**：
| 方案 | 优点 | 缺点 |
|------|------|------|
| 全量注入 | 简单、完整 | Token 消耗大、噪声多 |
| 渐进式披露 | 节省 Token、精准 | 实现复杂、可能漏召回 |

Claude-Mem 选择渐进式披露，因为：
1. Token 是有限且昂贵的资源
2. 大多数任务只需要少量相关上下文
3. 按需获取让 Claude 主动决定需要什么

---

## ⚠️ 常见误区

| 误区 | 正确做法 |
|------|----------|
| ❌ 存储所有原始工具调用记录 | ✅ 使用 AI 生成语义摘要，压缩存储 |
| ❌ 会话开始时全量注入历史上下文 | ✅ 渐进式披露，先注入索引，按需获取详情 |
| ❌ 在数据库层处理隐私数据 | ✅ 在 Hook 层（边缘）就剥离敏感内容 |
| ❌ 为每个场景设计专用工具 | ✅ 遵循 3 层工作流：search → filter → get_observations |
| ❌ 将记忆系统与 Agent 核心逻辑耦合 | ✅ 利用 Hook 机制实现零侵入扩展 |

---

## ✅ 行动清单

### 立即可做（今天）
- [ ] 安装 Claude-Mem 插件，体验持久化记忆功能
- [ ] 阅读 `/plugin/hooks/` 目录，理解 5 个 Hook 的实现

### 短期实践（本周）
- [ ] 分析 Claude-Mem 的数据库 Schema 设计
- [ ] 研究 MCP 搜索工具的 3 层工作流模式
- [ ] 尝试使用 `<private>` 标签控制隐私内容

### 长期提升（持续）
- [ ] 为自己的 Agent 项目设计记忆系统架构
- [ ] 探索混合检索（FTS5 + 向量）的最佳实践
- [ ] 思考渐进式披露在其他场景的应用

---

## 🔗 相关阅读

- [Anthropic Agent 评估指南](./2026-01-17-anthropic-agent-evals.md) - Agent 评估方法论
- [Quest 自进化 Agent](./2026-01-17-quest-self-evolving-agent.md) - 自主学习的 Agent 设计

---

## 📋 一页纸总结

### 核心要点（5 条）
1. **Hook 机制是 Agent 增强的关键入口**：无侵入地扩展 AI 能力
2. **语义压缩优于原始存储**：用 AI 生成摘要，平衡存储成本和信息保留
3. **渐进式披露是 Token 优化的核心策略**：按需加载而非全量注入
4. **混合检索提升召回质量**：FTS5 + 向量搜索双保险
5. **隐私控制要在边缘完成**：越早剥离敏感数据越安全

### 金句摘录
> "没有记忆的 AI Agent 就像失忆症患者——每次对话都从零开始。"

> "存储摘要而非原始数据，大幅节省存储和检索成本。"

> "Hook 层是'边缘处理'，是数据进入系统的第一道关卡。"

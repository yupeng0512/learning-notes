# MCP 架构文档精读

> 原文：https://modelcontextprotocol.io/docs/learn/architecture
> 精读日期：2026-01-05

## 一、文档结构概览

这篇文档回答了一个核心问题：**MCP 是如何让 AI 应用与外部世界连接的？**

```
MCP 架构
├── 参与者（Who）：主机、客户端、服务器
├── 分层（How）：数据层 + 传输层
├── 原语（What）：工具、资源、提示...
└── 生命周期（When）：初始化 → 通信 → 终止
```

---

## 二、核心概念深度解析

### 1. 三个参与者的关系

```
┌─────────────────────────────────────────────┐
│              MCP Host (主机)                 │
│         如 Claude Desktop, VS Code          │
│                                             │
│  ┌─────────────┐  ┌─────────────┐           │
│  │ MCP Client  │  │ MCP Client  │  ...      │
│  └──────┬──────┘  └──────┬──────┘           │
└─────────┼────────────────┼──────────────────┘
          │                │
          ▼                ▼
   ┌──────────────┐ ┌──────────────┐
   │ MCP Server A │ │ MCP Server B │
   │   (Sentry)   │ │  (Database)  │
   └──────────────┘ └──────────────┘
```

**关键理解**：
- **Host** 是"老板"，管理多个 Client
- **Client** 是"员工"，每个负责维护一个 Server 连接
- **Server** 是"外包商"，提供具体能力

**思考题**：为什么要分 Host 和 Client，而不是 Host 直接连 Server？

> 答案：解耦。Host 专注业务逻辑，Client 专注连接管理。一个 Host 可以同时连接多个 Server，每个 Client 独立管理自己的连接状态。

---

### 2. 两层架构

| 层次 | 职责 | 类比 |
|------|------|------|
| **数据层** | 定义"说什么" - 消息格式、语义 | 语言（中文/英文） |
| **传输层** | 定义"怎么说" - 通道、认证 | 通信方式（电话/邮件） |

**传输层的两种机制**：

| 传输方式 | 适用场景 | 特点 |
|----------|----------|------|
| **Stdio** | 本地进程 | 简单、低延迟、无网络 |
| **Streamable HTTP** | 远程服务 | 支持 SSE、可穿透防火墙 |

---

### 3. 六大原语

这是 MCP 的"词汇表"，分为服务器端和客户端：

**服务器提供的（给 AI 用）**：

| 原语 | 作用 | 例子 |
|------|------|------|
| **Tools** | 可执行的函数 | `search_database()`, `send_email()` |
| **Resources** | 只读数据源 | 文件内容、数据库记录 |
| **Prompts** | 可复用模板 | 代码审查模板、翻译模板 |

**客户端提供的（给 Server 用）**：

| 原语 | 作用 | 例子 |
|------|------|------|
| **Sampling** | 请求 LLM 补全 | Server 需要 AI 帮忙分析 |
| **Elicitation** | 请求用户输入 | Server 需要用户确认 |
| **Logging** | 发送日志 | 调试信息、错误报告 |

**思考题**：为什么 Sampling 是客户端原语？

> 答案：Server 本身没有 LLM 能力，但有时需要 AI 辅助。通过 Sampling，Server 可以"借用" Host 的 LLM 能力。

---

### 4. 通信协议（JSON-RPC 2.0）

所有消息都遵循这个格式：

```json
{
  "jsonrpc": "2.0",
  "id": 1,              // 请求标识（通知没有 id）
  "method": "xxx",      // 方法名
  "params": {}          // 参数
}
```

**三种消息类型**：
1. **Request** - 需要响应（有 id）
2. **Response** - 对 Request 的回复
3. **Notification** - 单向通知（无 id）

---

### 5. 生命周期

```
Client                          Server
   │                               │
   │──── initialize ──────────────▶│  1. 发送能力
   │◀─── initialize response ──────│  2. 返回能力
   │──── initialized notification ▶│  3. 确认就绪
   │                               │
   │◀──── (正常通信) ─────────────▶│  4. 工作阶段
   │                               │
   │──── close ───────────────────▶│  5. 关闭连接
```

**关键点**：MCP 是**有状态协议**，必须先握手再通信。

---

## 三、实际工作流程

以"查询天气"为例：

```
1. 用户问："旧金山天气怎么样？"

2. AI 应用查看已注册的工具，发现有 weather_current

3. AI 决定调用工具：
   {
     "method": "tools/call",
     "params": {
       "name": "weather_current",
       "arguments": { "location": "San Francisco" }
     }
   }

4. MCP Client 路由请求到对应的 Weather Server

5. Server 执行并返回结果

6. AI 整合结果回答用户
```

---

## 四、核心设计理念

| 特性 | 说明 | 好处 |
|------|------|------|
| **动态性** | 工具可热插拔 | 无需重启即可扩展能力 |
| **实时性** | 基于通知机制 | 无需轮询，及时响应变化 |
| **解耦性** | 分层 + 分角色 | 各组件独立演进 |
| **标准化** | JSON-RPC 2.0 | 跨语言、易实现 |

---

## 五、与 Tool Use 的关联

| 概念 | Tool Use | MCP |
|------|----------|-----|
| 工具定义 | 在 API 调用时传入 | Server 动态提供 |
| 工具发现 | 静态（开发时确定） | 动态（运行时发现） |
| 执行位置 | 你的代码 | MCP Server |

**MCP 的价值**：把 Tool Use 从"硬编码"变成"即插即用"。

---

## 六、关键要点速记

1. **三角色**：Host（管理） → Client（连接） → Server（能力）
2. **两层**：数据层（JSON-RPC）+ 传输层（Stdio/HTTP）
3. **六原语**：Tools、Resources、Prompts | Sampling、Elicitation、Logging
4. **有状态**：必须 initialize → work → close
5. **动态发现**：工具列表可实时变更，通过 notification 通知
